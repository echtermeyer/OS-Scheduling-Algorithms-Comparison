% !TEX root =  master.tex

\section{Innerhalb von Betriebssystemen}
Ein häufiges Anwendungsgebiet von \ac{FCFS} ist für Aufgaben der Batch-Verarbeitung, da hierbei der Convoy-Effekt nicht entscheidend ist. Ein klassisches Beispiel ist das Druckmanagement in frühen Betriebssystemen, wo Druckaufträge in der Reihenfolge ihres Eintreffens abgearbeitet werden.  %\textit{Referenz:} Silberschatz, Galvin, and Gagne. \textit{Operating System Concepts}. 9th ed., John Wiley \& Sons, 2012.

Round Robin hingegen ist ein weit verbreiteter Scheduling Algorithmus in zeitkritischen Betriebssystemen. Ein Beispiel hierfür ist das Thread-Scheduling in Unix-basierten Systemen, bei dem jedem Thread eine feste Zeitscheibe zugeteilt wird. %\textit{Referenz:} Tanenbaum, Andrew S., and Bos, Herbert. \textit{Modern Operating Systems}. 4th ed., Pearson, 2014.

\ac{MLQ} wird in modernen Betriebssystemen wie Linux angewendet, um Prozesse basierend auf ihrer Priorität zu ordnen, wobei systemkritische Prozesse höher priorisiert werden als Benutzerprozesse. % \textit{Referenz:} Love, Robert. \textit{Linux Kernel Development}. 3rd ed., Addison-Wesley Professional, 2010.

In modernen Betriebssystemen ist der Aufbau der Prozessverwaltung und Anwendung von Scheduling Algorithmen ein komplexes Thema, welches in der Praxis eine Vielzahl von Anforderungen erfüllen muss. Die hier vorgestellten Algorithmen sind nur ein kleiner Ausschnitt der Vielzahl von Scheduling Algorithmen, die in modernen Betriebssystemen zum Einsatz kommen.

\subsubsection{Windows}
Windows verwendet beispielsweise 7 Prioritätsstufen.
Prozesse können sich selbst die folgenden Stufen zuweisen:
\begin{multicols}{3}
    \begin{itemize}[noitemsep]
        \item IDLE
        \item BELOW NORMAL
        \item NORMAL
        \item ABOVE NORMAL
        \item HIGH
        \item REALTIME
    \end{itemize}
\end{multicols}

Innerhalb eines Prozesses können die einzelnen Threads dann jeweils 7 Prioritätsebenen haben, die die Threads untereinander sortieren:
\begin{multicols}{3}
    \begin{itemize}[noitemsep]
        \item IDLE
        \item LOWEST
        \item BELOW NORMAL
        \item NORMAL
        \item ABOVE NORMAL
        \item HIGHEST
        \item CRITICAL
    \end{itemize}
\end{multicols}

Windows verwendet beide Prioritätszuweisungen um dem Thread eine Basispriorität zu geben, die zwischen 0 und 31 liegt \autocite{KarlBridgeMicrosoft.2023}.

\subsubsection{MacOS}
Mit der Einführung der neuen M-Serie Prozessoren unterteilt Apple die Prozessorkerne in Performance- und Effizienzkerne. Die Performancekerne sind für rechenintensive Aufgaben und die Effizienzkerne für weniger rechenintensive Aufgaben zuständig \autocite{hoakley.2022}

Allgemein verwendet MacOS ähnlich wie Windows verschiedene Prioritätsstufen oder Quality of Services, die sich in 4 Kategorien unterteilen lassen:
\begin{multicols}{2}
    \begin{itemize}[noitemsep]
        \item Background
        \item Utility
        \item User Initiated
        \item User Interactive
    \end{itemize}
\end{multicols}
Prozesse der Priorität Background werden nur auf den Effizienzkernen ausgeführt, während Prozesse von höherer Priorität auf beiden Prozessorkernarten ausgeführt werden können.
Entwickler können das Verhalten eines Prozesses steuern und beispielsweise festlegen, dass ein User Initiated Process trotz des hohen Quality of Service nur den Effizienzkern verwenden soll.
Laut \Citeauthor{hoakley.2022b} wird innerhalb der einzelnen Prioritätsstufen eine Art \ac{FCFS} verwendet, wobei die Prozesse in der Reihenfolge ihres Eintreffens abgearbeitet werden \autocite{hoakley.2022b}. 

